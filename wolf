#!/usr/bin/perl
# author: seth
# tab-size: 2

use strict;
use warnings;

use Data::Dumper;  # Dumper
use File::Slurp qw/slurp/;
use Getopt::Long qw(:config bundling);
use Pod::Usage;

# global functions
# ================
# sub _clean
# 	delete temp files
#
# sub _cleanup
# 	run clean and exit
#
# sub syntaxCheck
# 	check cli syntax and parse params
#
# wolf functions
# ================
# sub changed_bbl
# 	checks, whether bbl file has changed
#
# sub changed_orig_files
# 	checks, whether original files have changed
#
# sub check_for_pdf_annotations
# 	show whether pdf annotations exist
#
# sub copyfile
# 	copy a file
#
# sub extract_bibfiles
# 	extract bibfiles from latex file, and append extensions '.bib'
#
# sub extract_bibstyle
# 	extract bibstyle from latex file
#
# sub extract_usedfiles
# 	extract filenames from latex file
#
# sub filename2temp
# 	generate temp filename from orig filename
#
# sub format_std_out
# 	get errors and warnings from stdout; returns compile mode
#
# sub format_std_out_pdflatex
# 	get errors and warnings from tex output; used by format_std_out
#
# sub get_first_found_exe
# 	search path for a given number of executable files. break on first found file.
#
# sub get_pdf_viewer_annotations
# 	cope with okulars annotations
#
# sub get_pids
# 	get pid for a given command
#
# sub interprate_error
# 	try to interprate error and translate it into more readable text
#
# sub latex_compile
# 	compile latex file if changes are detected
#
# sub load_latex_editor
# 	load gvim or other latex editor
#
# sub load_pdf_viewer
# 	load a pdf viewer, returns the name of the pdf viewer and a status code
#
# sub msg
# 	print messages to stdout
#
# sub msg_colored
# 	print colored messages to stdout
#
# sub newest_change
# 	get newest file of a given array of filenames
#
# sub ordered_hash_ref
# 	return ref to ordered (empty) hash 
#
# sub parse_tex_log
# 	get errors and warnings from tex log; returns compile mode
#
# sub print_tex_log_messages
# 	print formatted warnings/errors/...
#

$| = 1;
my @_unlink_files = ();
sub _clean{
	map unlink, @_unlink_files;
}

sub _cleanup{
	_clean();
	exit 1;
}

$SIG{'INT'} = \&_cleanup;
$SIG{'TERM'} = \&_cleanup;
$SIG{'KILL'} = \&_cleanup;
$SIG{'__DIE__'} = \&_clean;

$main::VERSION = '1.28.4'; # 20171122

sub syntaxCheck{
	my %params = ( # default cli params
		'check-missing'   => 1,                # check for missing files
		'editors'         => 'gvim|kile|kate', # text editor
		'exit'            => 0,                # exit after compilation
		'colors'          => 1,                # use colors
		'gui'             => 1,                # use some text editor and pdf viewer
		'format-output'   => 1,                # format std output
		'min-crossrefs'   => undef,            # bibtex --min-crossrefs
		'pdflatex-output' => 1,                # show pdflatex-output
		'pdfviewers'      => 'evince|kpdf|okular|acroread', # pdf viewers
		'verbose'         => 1,                # trace; grade of verbosity
		'version'         => 0,                # diplay version and exit
	);
	GetOptions(\%params,
		"colors!",
		"editors=s",# => sub { $params{'editors'} = $_[1].'|'.$params{'editors'};},
		"exit",
		"format-output!",
		"check-missing!",
		"gui!",
		"min-crossrefs=i",
		"pdflatex-output!",
		"pdfviewers|pdf-viewers=s",# => sub {
		#	$params{'pdfviewers'} = $_[1].'|'.$params{'pdfviewers'};
		#},
		"silent|quiet|q" => sub { $params{'verbose'} = 0;},
		"very-verbose" => sub { $params{'verbose'} = 3;},
		"verbose|v:+",
		# auto_version will not auto make use of 'V'
		"version|V" => sub { Getopt::Long::VersionMessage();},
		"help|?|h" => sub { Getopt::Long::HelpMessage(
				-verbose => 99, 
				-sections => "NAME|SYNOPSIS|EXAMPLES");
		}, # auto_help will not auto make use of 'h'
		"man" => sub { pod2usage(-exitval=>0, -verbose=>2);},
	) or pod2usage(-exitval=>2);
	$params{'verbose'} = 1 unless exists $params{'verbose'};
	my @additional_params = (1,1); # number of additional params (min, max);
	if(@ARGV<$additional_params[0] 
			or ($additional_params[1] != -1 and @ARGV>$additional_params[1])){
		if($additional_params[0] == $additional_params[1]){
			print "number of arguments must be exactly $additional_params[0], but is " . 
				(0+@ARGV) . ".\n";
		}else{
			print "number of arguments must be at least $additional_params[0] and at " . 
				"most " . ($additional_params[1] == -1 ? 'inf' : $additional_params[1]) . 
				", but is " . (0 + @ARGV) . ".\n";
		}
		pod2usage(-exitval=>2);
	}
	if(!$params{'gui'}){
		$params{'pdfviewers'} = 'none';
		$params{'editors'} = 'none';
	}
	$params{'latexfile'} = $ARGV[0];
	return \%params;
}

{
	package Wolf;
	use Data::Dumper;  # Dumper
	use Date::Format;  # time2str
	use File::Compare; # compare
	use File::Copy;    # copy
	use File::Slurp qw/read_dir slurp/;
	use File::Spec;
	use List::MoreUtils qw(uniq);
	use Term::ANSIColor;
	use Tie::IxHash;   # ordered hashes

	sub new{
		my $class = shift;
		my $params = shift;
		my $self = bless {
			'biber'           => 0, # if 1 use biber
			'bibtex_params'   => $params->{'bibtex_params'},
			'color-def'       => {
				'err'            => 'bold white on_red',
				'warn'           => 'bold yellow on_black',
				'notice'         => 'yellow on_black',
				'std_suspicious' => 'white on_black',
			},
			'colors'          => $params->{'colors'},
			'format-output'   => $params->{'format-output'},
			'files-not-found' => [],
			'latexfile'       => $params->{'latexfile'}, # .tex extension will be deleted
			'max_line_len'    => 73, # maximum line length in latex log file
			'no_cont'         => $params->{'no_cont'} // 0, # if 1 then exit after compile
			'new_bbl'         => undef, # see sub changed_bbl
			'old_bbl'         => undef, # see sub changed_bbl
			'orig_ltx'        => undef, # orig latex file (with .tex extension), set later
			'exit_value'      => 0,
			'pdflatex-output' => $params->{'pdflatex-output'},
			'pdfviewer'       => undef,
			'tmp_ltx'         => 'temp_latex_file' . time() . 
				sprintf('%d', 1_000_000 * rand()),
			'tmp_ltx_f'       => undef, # tmp latex file (with .tex extension), set later  
			'usedfiles'       => undef, # will be defined a few lines after
			'verbosity'       => $params->{'verbosity'} // 1,
		}, $class;
		# check latex file
		unless(-e $self->{'latexfile'}.'.tex'){
			$self->{'latexfile'} =~ s/\.tex$//;
			unless(-e $self->{'latexfile'} . '.tex'){
				$self->msg(0, "file '$self->{'latexfile'}.tex' does not exist", 'error');
				exit 1;
			}
		}
		$self->{'orig_ltx'}  = $self->{'latexfile'} . '.tex';
		$self->{'tmp_ltx_f'} = $self->{'tmp_ltx'} . '.tex';
		$self->{'usedfiles'} = [$self->{'orig_ltx'}];
		# pdf viewer
		my $status_pdfviewer = $self->load_pdf_viewer($params->{'pdfviewers'});
		if($status_pdfviewer == -1){
			$self->msg(1, 'as you wish, no pdf viewer will be loaded.');
		}elsif($status_pdfviewer == 0){
			$self->msg(1, 'couldn\'t load any of the given pdf viewers (' . 
				join(', ', @{$params->{'pdfviewers'}}) . ').', 'warning');
			sleep 3;
		}
		return $self;
	}

	sub changed_bbl{
		my $self         = shift;
		my $changed      = 1;
		# if biber is used, this indicator will not work
		unless($self->{'biber'} == 1){
			# tmp bbl file is used for checking whether bibtex should be called
			my $bbl = $self->{'tmp_ltx'} . '.bbl';
			if(-e $bbl){
				$self->{'new_bbl'} = slurp($bbl);
				if(defined $self->{'old_bbl'}){
					$changed = undef if $self->{'old_bbl'} eq $self->{'new_bbl'};
					if(defined $changed){
						$self->msg(1, 'bbl file has changed.')
					}else{
						$self->msg(1, 'bbl file has not changed. probably no need to re-run ' . 
							'latex compiler');
					}
				}else{
					$self->msg(2, 'old bbl content not found, creating...');
				}
				$self->{'old_bbl'} = $self->{'new_bbl'};
			}else{
				$self->msg(0, 'could not load bbl file', 'warning');
			}
		}
		return $changed;
	}

	sub changed_orig_files{
		my $self    = shift;
		my $last_change_time_bak = shift;
		my $last_change_time     = shift;
		my $changed = undef;
		if(compare($self->{'orig_ltx'}, $self->{'tmp_ltx_f'})){
			$changed = 1;
			$self->msg(3, 'main tex file has changed');
		}elsif($last_change_time_bak < $last_change_time){
			$changed = 1;
			$self->msg(3, 'last change time has changed');
		}elsif(`find . -newer $self->{'tmp_ltx_f'}` =~ 
			/\.(?:cls|sty)$|\/gfx\/.*\.(?:eps|p[dg]f|png|tex)\n/m){
			$changed = 1;
			$self->msg(3, 'some used file has changed');
		}
		return $changed;
	}

	sub check_for_pdf_annotations{
		my $self      = shift;
		my $pdf_file  = shift;
		my ($exist_anno_file, $exist_anno, $infostring) = 
			$self->get_pdf_viewer_annotations($pdf_file);
		if($exist_anno_file){
			if(defined $self->{'pdfviewer'}){
				$self->msg(1, "else");
				$self->msg(1, "====");
				$self->msg(1, "your pdfviewer: $self->{'pdfviewer'}");
			}
			if($exist_anno>0){
				$self->msg(0, 
					'there seem to be annotations for this file that would be lost when ' . 
						'recompiling', 
					'warning');
				$self->msg(0, $infostring);
				$self->msg(0, 'press <ctrl+c> to leave, or <enter> to continue.');
				<STDIN>;
			}else{
				$self->msg(1, $infostring);
			}
		}
		return $exist_anno;
	}

	sub copyfile{
		my $self = shift;
		my $src  = shift;
		my $dest = shift;
		my $ret;
		if(-e $src){
			#$ret = `cp $src $dest`;
			$ret = copy($src, $dest) 
				or $self->msg(0, "copy failed: $! '$src'", 'warning');
		}else{
			$ret = 0;
		}
		return $ret;
	}

	sub extract_bibfiles{ # from latex file, and append extensions '.bib'
		my $self     = shift;
		my $bibfiles = [];
		my @latex_content = grep {!/^\s*%/} slurp $self->{'orig_ltx'};
		map {s/(?<!\\)(?:\\\\)*\K%.*//} @latex_content;
		my $latexcontent = join '', @latex_content;
		# \bibliography seems to add .bib, right?
		while($latexcontent =~ /\\bibliography\{(.*?)\}/g){
			push @$bibfiles, (map {$_ .= '.bib'} split /\s*,\s*/, $1);
		}
		# \addbibresource seems to need .bib, right?
		while($latexcontent =~ /\\addbibresource\{(.*?)\}/g){
			$self->{'biber'} = 1;
			push @$bibfiles, (split /\s*,\s*/, $1);
		}
		if($self->{'biber'} == 0 
			&& $latexcontent =~ /\\usepackage(?:\[([^\]]*)\])\{[^}]+\bbiblatex\b/s
			&& $1 =~ /\bbackend\s*=\s*biber\b/){
			$self->{'biber'} = 1;
		}
		if($self->{'biber'} > 0){
			$self->msg(1, 'using biber instead of bibtex');
			unless(`which biber`){
				$self->msg(0, 'could not find biber, ' 
					. 'but biber seems to be needed to compile the bibliography', 'error');
				$self->{'biber'} = 0;
			}
		}
		# check paths of $BIBINPUTS if file is not in current working directory
		my @bibinputs = split /:/, `kpsewhich --expand-path '\$BIBINPUTS'`;
		map {
			if(not -f $_){
				for my $path(@bibinputs){
					if(-f $path.'/'.$_){
						$_ = $path.'/'.$_;
						last;
					}
				}
			}
		} @$bibfiles;
		return $bibfiles;
	}

	sub extract_bibstyle{
		my $self      = shift;
		my $used_latex_files = [grep {m/\.tex\z/} @{$self->{'usedfiles'}}];
		my $bibstyles = [];
		for my $file(@$used_latex_files){
			if(-e $file){
				my $content = slurp($file); # for vim syntax highlighting: {
				while($content =~ /\\bibliographystyle\s*\{([^}]++)\}/gs){
					push @$bibstyles, (split /,\s*/, $1);
				}
			}else{
				$self->msg(0, "could not find file '$file'", 'error');
			}
		}
		return $bibstyles;
	}

	sub extract_usedfiles{ # from latex file
		my $self        = shift;
		my $latexfile   = shift // $self->{'orig_ltx'};
		my $usedfiles   = shift;
		my $method      = shift // 'flsfile';
		my $errors = [];
		if($method eq 'flsfile'){
			my $file_prefix = $self->{'tmp_ltx'};
			@$usedfiles = slurp($file_prefix . '.fls');
			my $path = shift @$usedfiles;
			$path =~ s/^PWD (.*)\n?/$1\//;
			@$usedfiles = uniq(
				grep {
					/^INPUT (?!\.\/$file_prefix)(?!$file_prefix)(.*)/ and 
					$_ = substr($1, 0, 1) eq '/' ? $1 : $path . $1;
				} @$usedfiles
			);
		# method till 2013-08-16: faulty because not all files were matched
		}elsif($method eq 'logfile'){
			my $file_prefix = $self->{'tmp_ltx'};
			@$usedfiles = slurp($file_prefix . '.log') =~ 
				m/^(?:\)+ )?\(\K[.\/][^ \s)]+|^\s*File: \K[.\/][^ \s]+/gm;
		# very old method till 2012: faulty because not all files were matched
		}elsif('texfile'){
			if(open(my $INFILE, '<', $latexfile)){
				while(my $line = <$INFILE>){
					next if $line =~ /^\s*%/; # skip comments, seth 2016-02-19
					while($line =~ /\\in(?:clude(?:graphics)?|put)\s*
							(?:\[[^\]]+\]\s*)? \{(.*?)\}/gx){
						my $filename = 
							-e $1.'.tex' ? $1.'.tex' :
							-e $1.'.eps' ? $1.'.eps' :
							-e $1.'.jpg' ? $1.'.jpg' :
							-e $1.'.pdf' ? $1.'.pdf' :
							-e $1.'.png' ? $1.'.png' : $1;
						unless(grep {$_ eq $filename} @{$self->{'usedfiles'}}){
							push @{$self->{'usedfiles'}}, $filename;
							push @$errors, @{$self->extract_usedfiles(
								$self->{'usedfiles'}[-1], undef, 'texfile'
							)}; # recursion!
						}
					}
				}
				close($INFILE);
			}else{
				push @$errors, "error reading file '$latexfile'. $!";
				#$self->msg(0, $errors->[-1]);
			}
		}
		return $errors;
	}

	sub filename2temp{
		my $self     = shift;
		my $filename = shift;
		$filename =~ s/[\/*?]/_/g;
		return 'temp_'.$filename;
	}

	sub format_std_out{
		my $self        = shift;
		my $cmd_entries = shift;
		for my $cmd_entry(@$cmd_entries){
			my $type = $cmd_entry->{'type'};
			my $cmd = $cmd_entry->{'cmd'};
			if($self->{'verbosity'} > 1){
				print "command: $cmd\n";
			}
			my $child_pid = open(my $stdout, '-|', "$cmd 2>&1");
			if($child_pid){
				if($self->{'verbosity'} > 0){
					if($self->{'format-output'} == 0){
						while(<$stdout>){
							print $_;
						}
					}else{
						if($type eq 'pdflatex'){
							if($self->{'pdflatex-output'}){
								$self->format_std_out_pdflatex($stdout, $type);
							}
						}else{
							# bibtex, biber or other cmds
							while(<$stdout>){
								print "$type: $_";
							}
						}
					}
				}
				waitpid $child_pid, 0;
			}else{ # no child pid -> is child
				# child should just die
				exit;
			}
			$self->{'exit_value'} = $?;
			$self->msg(4, 'last value: ' . $self->{'exit_value'});
			last if $? != 0;
		} # end for @$cmd_entries
	}

	sub format_std_out_pdflatex{
		my $self   = shift;
		my $stdout = shift;
		my $type   = shift;
		my $indent_depth = 0;
		my $cont_line = 0; # line is going to be continued
		my $cont_state; # e.g. a class or a package mentioned in a warning
		# the last parenthesis of the previous line was a '('
		my $opening_paren_prev_line = 0; 
		my $opening_brace_prev_line = 0; 
		my $opening_chevron_prev_line = 0; 
		my $prev_line = "\n"; 
		my $bracket_open = 0; 
		my $color;
		my $leave_space = 1;
		while(<$stdout>){
#			LOOP: {
#				print(" digits"), redo LOOP if /\G\d+\b[,.;]?\s*/gc;
#				print(" lowercase"), redo LOOP
#				if /\G\p{Ll}+\b[,.;]?\s*/gc;
#				print(" UPPERCASE"), redo LOOP
#				if /\G\p{Lu}+\b[,.;]?\s*/gc;
#				print(" Capitalized"), redo LOOP
#				if /\G\p{Lu}\p{Ll}+\b[,.;]?\s*/gc;
#				print(" MiXeD"), redo LOOP if /\G\pL+\b[,.;]?\s*/gc;
#				print(" alphanumeric"), redo LOOP
#				if /\G[\p{Alpha}\pN]+\b[,.;]?\s*/gc;
#				print(" line-noise"), redo LOOP if /\G\W+/gc;
#				print ". That's all!\n";
#			}
			my $line = $_;
			$self->msg(4, "[new line '" . substr($line, 0, -1) . "']");
			my $output = '';
			my $line_was_cont = $cont_line; # line was being continued
			#next if $prev_line =~ /^\s*$/ and $line =~ /^\s*$/;
			$prev_line = $line;
			my $cont_state_tmp; # cont_state just for this line
			while(length($line) > 0){
				$self->msg(4, "[present line '" . substr($line, 0, -1) . "']");
				my $indent = '  ' x $indent_depth;
				# brackets [x ...], x = int
				if($bracket_open){
					$self->msg(4, '[bracket is open]');
					if($line =~ /\]/){
						$bracket_open = 0;
						--$indent_depth;
					}
					if($line =~ /^(\s*[{<][^{<>}]*)/){
						$self->msg(4, '[got < or {]'); # }
						$line = substr($line, length($1));
						$output .= $indent.$1;
						$cont_line = 1;
						$opening_paren_prev_line = 0;
					}elsif($line =~ /^([^{<>}]*[>}])/){
						$line = substr($line, length($1));
						$output .= "$1\n";
						$cont_line = 0;
						$opening_paren_prev_line = 0;
					}else{ # no [<>{}]
						$output .= $line;
						$line = '';
						$cont_line = 0;
						$opening_paren_prev_line = 0;
					}
					$line =~ s/^\s+//;
				}elsif($line =~ /^((?:[^\[]|\[[0-9]+\])*+) (\[[0-9]+\s*+) [{<]/x
						# } for vim
						and length($line) > 78){
					$self->msg(4, '[got bracket]');
					$line = substr($line, length($2) + length($1));
					my $pre_bracket = $1;
					my $bracket = $2;
					$bracket =~ s/^\s*+(.*\S)\s*$/$1/;
					$output .= $indent . $pre_bracket . "\n";
					$output .= $indent . $bracket . "\n";
					++$indent_depth;
					$cont_line = 0;
					$bracket_open = 1;
					$opening_paren_prev_line = 0;
				}
				# latex warning with explicit class/package name
				elsif($line =~ /^(?<line>(?:Class|Package)\s(?<packageclass>[a-zA-Z0-9_-]+)\s[wW]arning.*)$/){
					$cont_state_tmp = $+{'packageclass'};
					$self->msg(4, "[got latex warning of package '$cont_state_tmp']");
					$output .= $indent . $+{'line'};
					$line = '';
					$cont_line = 0;
					$opening_paren_prev_line = 0;
				}
				# general latex warning
				elsif($line =~ /^(LaTeX Warning: .*|pdfTeX warning: pdflatex .*)$/){
					$self->msg(4, '[got latex warning]');
					$output .= $indent . $1;
					$line = '';
					$cont_line = 1;
					$opening_paren_prev_line = 0;
				}
				# ... ( ... )
				elsif($line =~ /^(?<line>[^()]*+ \( (?<packageclass>[^()]*+) \))/x){
					if(defined $cont_state && $cont_state eq $+{'packageclass'}){
						$cont_state_tmp = $cont_state;
						$self->msg(4, "[got ($cont_state)]");
						$output .= $indent . $line;
						$line = '';
						$cont_line = 0;
						$opening_paren_prev_line = 0;
					}else{
						#undef $cont_state;
						$self->msg(4, '[got ()]');
						$output .= $indent if !$cont_line;
						$output .= $+{'line'} . "\n";
						$line = substr($line, length($+{'line'}));
						$cont_line = 0;
						$leave_space = 0;
						$opening_paren_prev_line = 0;
					}
				}
				# < ...
				elsif($line =~ /^(\s*+)(<\/[a-zA-Z0-9.~+\/-]++)/x){
					$self->msg(4, '[got <]');
					$output .= $indent if !$cont_line;
					$output .= "$2";
					$line = substr($line, length($1) + length($2));
					$cont_line = 1;
					$opening_chevron_prev_line = 1;
					$leave_space = 0;
					$opening_paren_prev_line = 0;
				}
				# ... >
				elsif($opening_chevron_prev_line){
					$self->msg(4, '[expecting >]');
					if($line =~ /^([a-zA-Z0-9.~+\/-]*+>)/x){ # { for vim
						$self->msg(4, '[got }]');
						$output .= $indent if !$cont_line;
						$output .= "$1\n";
						$line = substr($line, length($1));
						$leave_space = 0;
						$opening_paren_prev_line = 0;
						$opening_chevron_prev_line = 0;
						$cont_line = 0;
					}elsif($line !~ /^\s*$/){
						$opening_chevron_prev_line = 0;
						$cont_line = 0;
					}else{
						$line = '';
					}
				}
				# { ...
				elsif($line =~ /^(\s*+)(\{\/[a-zA-Z0-9.~+\/-]++)/x){
					$self->msg(4, '[got {]'); # } for vim
					$output .= $indent if !$cont_line;
					$output .= "$2";
					$line = substr($line, length($1) + length($2));
					$cont_line = 1;
					$opening_brace_prev_line = 1;
					$leave_space = 0;
					$opening_paren_prev_line = 0;
				}
				# ... }
				elsif($opening_brace_prev_line){ # { for vim
					$self->msg(4, '[expecting }]');
					if($line =~ /^([a-zA-Z0-9.~+\/-]*+\})/x){ # { for vim
						$self->msg(4, '[got }]');
						$output .= $indent if !$cont_line;
						$output .= "$1\n";
						$line = substr($line, length($1));
						$leave_space = 0;
						$opening_paren_prev_line = 0;
						$opening_brace_prev_line = 0;
						$cont_line = 0;
					}elsif($line !~ /^\s*$/){
						$opening_brace_prev_line = 0;
						$cont_line = 0;
					}else{
						$line = '';
					}
				}
				# ( ...
				elsif($line =~ /^\s*+\( ( [^()]*+ )/x){
					$output .= $indent if !$cont_line;
					my $filename = $1;
					$self->msg(4, "[got (, length = " . length($filename) . "]");
					$line = substr($line, length($filename) + 1);
					++$indent_depth;
					if(length($filename) == 79 and $filename =~ /^\S+$/){
						chomp $filename;
						$output .= "($filename";
						$cont_line = 1;
						$opening_paren_prev_line = 1;
					}else{
						$output .= "($filename\n";
						$output =~ s/\n\n\z/\n/;
						$cont_line = 0;
						$opening_paren_prev_line = 0;
					}
					$leave_space = 0;
				}
				# ... )
				elsif($indent_depth > 0 and $line =~ /^([^()]*+) \)/x){
					$self->msg(4, '[got )]');
					my $prefix = $1; 
					$line = substr($line, length($1) + 1);
					$line =~ s/^ +//;
					$line = '' if $line =~ /^\s+$/;
					if($prefix =~ /^\s*$/){
						$output .= "\n" if $cont_line and !$opening_paren_prev_line;
					}else{
						$output .= $indent if !$cont_line;
						$output .= $prefix;
						$output .= "\n" if !$opening_paren_prev_line;
					}
					--$indent_depth;
					$indent = '  ' x $indent_depth;
					$output .= $indent if !$opening_paren_prev_line;
					$output .= ")\n";
					$cont_line = 0;
					$opening_paren_prev_line = 0;
				}
				# { ... }
				#elsif($line =~ /^( [^()]*+ \( [^()]*+ \) [^()]*+ )/x){
				#	$self->msg(4, '[got ()]');
				#	$output .= $indent if !$cont_line;
				#	$output .= $1;
				#	$line = substr($line, length($1));
				#	$cont_line = length($line) > 0 ? 1 : 0;
				#	$opening_paren_prev_line = 0;
				#}
				else{
					if($line !~ /^\s*$/ or $leave_space){
						$output .= $indent if !$cont_line;
						$output .= $line;
						$line = '';
						$cont_line = 0;
						$opening_paren_prev_line = 0;
					}else{
						$line = '';
					}
				}
			}
			$cont_state = $cont_state_tmp; # maybe set undef here
			$leave_space = 1;
			chomp $output;
			$output =~ s/\Q$self->{'tmp_ltx'}/$self->{'latexfile'}/g;
			my $parsed = "$type: ";
			print $parsed if $line_was_cont == 0;
			if($output =~ /\b(?i:error|warning)\b|(?:Overfull |Underfull )/ 
				|| defined($cont_state)
			){
				$color = $self->{'color-def'}{'std_suspicious'};
			}
			$self->msg_colored(1, '' . (join "\n$parsed", split /\n/, $output), $color);
			if($cont_line == 0){
				undef $color;
				print "\n";
			}
		}
	}

	# search path for a given number of executable files. break on first found file.
	# get pid for a given command
	sub get_first_found_exe{
		my $self       = shift;
		my $candidates = shift;
		my @path = File::Spec->path();
		for my $candidate(@$candidates){
			$self->msg(2, "* $candidate");
			for my $dir(@path){
				my $file = File::Spec->catfile($dir, $candidate);
				return $candidate if -x $file;
			}
		}
		return undef;
	}

	sub get_pdf_viewer_annotations{
		my $self               = shift;
		my $pdf_file_full_path = shift;
		$pdf_file_full_path=~/([^\/]+)$/;
		my $pdf_file = $1;
		my $pdf_size = (stat $pdf_file_full_path)[7];
		my $numAnnotations = 0;
		my $existAnnotations = 0;
		my $info_string = '';
		my @okular_files = ();
		my @kdedirs = grep /^.kde\d*$/, read_dir($ENV{'HOME'});
		for my $kdedir(@kdedirs){
			my $path = $ENV{'HOME'}.'/'.$kdedir.'/share/apps/okular/docdata';
			if(-e $path){
				if($self->{'verbosity'} > 1){
					$info_string .= "'$path' exists, looking for '$pdf_file' xml-files.\n";
				}
				push @okular_files, grep {
					/^\d+\Q.$pdf_file.xml\E$/ and $_="$path/$_";
				} read_dir($path);
			}
		}
		if(@okular_files>0 and $self->{'verbosity'} > 0){
			$info_string .= "found some okular annotations for files with similar filename:\n";
		}
		map {
			my $filemoddate = time2str("%Y-%m-%d %T", (stat $_)[9]);
			my $filesize = (stat $_)[7];
			/\/(\d+)\Q.$pdf_file.xml\E$/;
			my $pdf_file_size_from_file_name = $1;
			if(defined $pdf_size and $pdf_file_size_from_file_name eq $pdf_size){
				++$numAnnotations if $filesize > 500;
				$existAnnotations = 1;
				$info_string .= '* ' if $self->{'verbosity'} > 0;
			}else{
				$info_string .= '  ' if $self->{'verbosity'} > 0;
			}
			$info_string .= "$filemoddate, $_ ($filesize B)\n" if $self->{'verbosity'} > 0;
		} sort {(stat $a)[9] <=> (stat $b)[9]} @okular_files;
		return ($existAnnotations, $numAnnotations, $info_string);
	}

	sub get_pids{
		my $self      = shift;
		my $processRE = shift;       # regular expression for processes
		my $user      = $ENV{USER};
		# the following line may cause fork problems "resource temporarily unavailable"
		#my $stdout = get_syscall_output_threaded("ps -ef | grep -v grep");
		my $stdout = `ps -ef | grep -v grep`;
		# fetch all processes of user
		my @pids = ();
		map {push @pids, $1 if /$user\s+ # user
			(\d+)\s+          # pid
			\d+\s+            # parent pid
			\d+\s+            # ?
			(?:\d\d:\d\d|[a-zA-Z]+\d+|\S+)\s+ # time
			[a-z0-9\/?]+\s+   # display
			\d\d:\d\d:\d\d\s+ # time
			.*$processRE.*    # cmd
			/x} split /\n/, $stdout;
		return \@pids;
	}

	sub interprate_error{
		my $self      = shift;
		my $type      = shift; # ltx_..., bib_...
		my $error     = shift;
		my $could_interprate_error = 0;
		my $interpretation;
		if($type =~ /^ltx_/){
			my $err_re = qr/(?:!|[^:\n]+\.[^:\n]+:[0-9]+:)/;
			if($error =~ /^! Undefined control sequence\.\nl.(\d+) (?:\.\.\..*)(\\\S+)/){
				$could_interprate_error = 1;
				$interpretation = "command '$2' in line $1 is unknown. maybe the command is misspelled or you didn't load the right package.";
			}elsif($error=~/^([^:\n]+\.[^:\n]+):([0-9]+): Undefined control sequence\.\n.*?\.\.\..*(\\\S+)/){
				$could_interprate_error = 1;
				my $filename = $1;
				my $line = $2;
				my $command = $3;
				$filename = $self->{'orig_ltx'} if $filename =~ /\Q$self->{'tmp_ltx_f'}\E$/;
				$interpretation = "command '$command' in line $line of file '$filename' is unknown.\n" . 
					"maybe the command is misspelled or you didn't load the right package.";
			}
			if($error =~ /^$err_re Missing \$ inserted.\s+(?:.*\s+){1,3}l.(\d+)/ or 
				$error =~ /^! Extra \}, or forgotten \$.\s+.*\s+l.(\d+)/){
				$could_interprate_error = 1;
				$interpretation = "probably you forgot a dollar-sign (\$) somewhere around line $1.";
			}
			if($error =~ /^$err_re Argument of \\\@\Qcaption has an extra \E\}\..*\s+\\par/s){
				$could_interprate_error = 1;
				$interpretation = "maybe you should use '\\newline' instead of '\\\\'.";
			}
			if($error =~ /^$err_re (?:LaTeX Error: )?Float\(s\) lost\./){
				$could_interprate_error = 1;
				$interpretation = "1. The most likely reason is that you placed a float " . 
					"or a \\marginpar command inside another float or marginpar, or inside " .
					"a minipage environment, a \\parbox or \\footnote. Note that the error " .
					"may be detected a long way from the problematic command(s), so the " . 
					"techniques of tracking down elusive errors all need to be called into " .
					"play. (source: http://www.tex.ac.uk/FAQ-fllost.html)\n" . 
					"2. maybe you placed a \\todo inside a \\footnote?";
			}
			if($error =~ /^LaTeX Font Warning: Font shape .O[A-Z0-9]{2}\/cm(?:[a-z]+\/)+[a-z]+' in size <.*> not available/s){
				$could_interprate_error = 1;
				$interpretation = "try inserting '\\RequirePackage{fix-cm}' _before_ \\documentclass{...}, see <http://tex.stackexchange.com/questions/4824/what-do-these-font-shape-warnings-mean>";
			}
			if($error =~ /LaTeX Warning: Marginpar on page [0-9]+ moved\./s){
				$could_interprate_error = 1;
				$interpretation = "sometimes \\todo (from todonotes package) makes problems. " . 
					"maybe you placed a \\todo and a \\label inside of a \\caption? " . 
					"this warning can be avoided in many cases by using \\todo[inline] instead of pure \\todo.";
			}
			if($error =~ /Package amsmath Warning: Unable to redefine math accent \\vec/s){
				$could_interprate_error = 1;
				$interpretation = "try inserting '\\RequirePackage[cmex10]{amsmath}' _before_ \\documentclass{...}, see <http://tex.stackexchange.com/questions/102507/how-to-fix-this-amsmath-warning-about-redefining-vec/251672#251672>";
			}
		}elsif($type =~ /^bib_/){
		}
		if($could_interprate_error){
			print "\n";
			$self->msg(1, "hint: ".(join ' 'x11, split /(\n)/, $interpretation));
			#$self->msg(1, "hint: $interpretation");
		}
		return $could_interprate_error;
	}

	sub latex_compile{
		my $self        = shift;
		my $orig_btx    = $self->extract_bibfiles(); # orig bibtex files
		my $pdf_file    = $self->{'latexfile'} . '.pdf'; # resulting pdf file
		my $other_files = [];                        # filenames of files, that are used
		# the following files will be cleaned up (deleted) when wolf is stopped
		push @_unlink_files, $self->{'tmp_ltx'} . $_ for ('.tex', '.log', '.pdf', 
			'.aux', '.bcf', '.bbl', '.blg', '-blx.bib', '.brf', '.fls', '.glsdefs', 
			'.idx', '.ilg', '.ind', '.loa', '.lof', '.lot', '.nav', '.nlo', '.out', 
			'.run.xml', '.snm', '.tdo', '.toc', '.xtr');
		push @_unlink_files, $self->filename2temp($_) for @$orig_btx;
		unless(defined $self->{'bibtex_params'}->{'min-crossrefs'}){
			my $bib_styles = $self->extract_bibstyle();
			# see http://tug.ctan.org/biblio/bibtex/contrib/IEEEtran/IEEEtran_bst_HOWTO.pdf
			$self->msg(3, 'found used bibtex styles: '. (join ', ', @$bib_styles));
			if(grep {$_ eq 'IEEEtran'} @$bib_styles){
				$self->msg(2, 'setting min-crossrefs to 900');
				$self->{'bibtex_params'}->{'min-crossrefs'} = 900;
			}
		}
		my %compile_mode = (); # () = do nothing; other possibilities:
		# latex: compile latex (without bibtex); 
		# bib: compile bibtex and latex
		# del_aux: delete aux-file
		# idx: call makeindex
		my $compiling_counter = 0;
		my $complete_latex_command = "pdflatex -recorder -file-line-error " . 
			"-shell-escape -interaction=nonstopmode --halt-on-error $self->{'tmp_ltx_f'}";
		my $mincrossrefs = defined $self->{'bibtex_params'}{'min-crossrefs'} ? 
			' --min-crossrefs=' . $self->{'bibtex_params'}{'min-crossrefs'} : '';
		my $last_change_time_bak = 0;
		$self->msg(3, 'now start looping, i.e. initial compilation and afterwards ' .
			'waiting for file changes');
		while(1){
			my $force_error_log = 0;
			my $last_change_time = $self->newest_change($other_files);
			for my $bib(@$orig_btx){
				if(-f $bib){ # if bibtex files exist and have been changed
					if(compare($bib, $self->filename2temp($bib))){
						$compile_mode{'bib'} = 1;
						$self->msg(2, "bib file '$bib' has changed");
					}
				}else{
					$self->msg(0, "file '$bib' not found", 'error');
					sleep 1;
				}
			}
			# in some cases the aux file should be deleted
			if($compile_mode{'del_aux'}){ 
				$self->msg(2, "delete aux file, need to re-compile");
				unlink "$self->{'tmp_ltx'}.aux";
				delete $compile_mode{'del_aux'};
				$compile_mode{'latex'} = 1;
			}elsif(not defined $compile_mode{'latex'} or $compile_mode{'latex'} == 0){
				# check whether original source files have been changed
				$compile_mode{'latex'} = $self->changed_orig_files(
					$last_change_time_bak, $last_change_time);
				if($compile_mode{'latex'}){
					$self->msg(2, "latex files changed; need to re-compile");
				}
				# check whether missing files are there now
				for my $fnf(@{$self->{'files-not-found'}}){
					if(-e $fnf){
						$self->msg(1, "found missing file '$fnf'; need to re-compile");
						$compile_mode{'latex'} = 1;
						# fnf-array will be reset and rebuilt in parse_tex_log
						last;
					}
				}
			}
			if($compile_mode{'bib'} || $compile_mode{'latex'}){ # compile and use bibtex
				# copy orig bibtex files to temp bibtex files
				# copy orig latex file to temp latex file
				# compile latex file to generate aux file
				# use bibtex on aux file to generate bbl and blg files
				if(@$orig_btx > 0){ # if there are bibtex files
					map {$self->copyfile($_, $self->filename2temp($_))} @$orig_btx;
					$self->copyfile($self->{'orig_ltx'}, $self->{'tmp_ltx_f'});
					$self->msg(3, 'run pdflatex and bibtex');
					$self->format_std_out([
						{'type' => 'pdflatex', 'cmd' => $complete_latex_command,}, 
					]);
					# separate call, because in some cases bibtex should be called, although 
					# pdflatex failed.
					# distinguish between bibtex and biber
					if($self->{'biber'} == 1){
						$mincrossrefs =~ s/min\K-(?=crossrefs)//; # param name differs in biber
						$self->format_std_out([
							{'type' => 'biber', 
								'cmd' => "biber$mincrossrefs $self->{'tmp_ltx'}",
							}, 
						]);
					}else{
						$self->format_std_out([
							{'type' => 'bibtex', 
								'cmd' => "bibtex$mincrossrefs $self->{'tmp_ltx'}",
							}, 
						]);
					}
					# check, whether bbl file has changed or bibtex-call is forced
					if($compile_mode{'bib'}){
						$compile_mode{'latex'} = 1;
						# create initial $self->{'old_bbl'}
						$self->changed_bbl() unless defined $self->{'old_bbl'};
					}else{
						$compile_mode{'latex'} = $self->changed_bbl();
						# if latex does not have to be called again, still the error log should be 
						# printed
						unless($compile_mode{'latex'}){
							$force_error_log = 1;
						}
					}
					$self->msg(3, "compile mode: " . Dumper(\%compile_mode));
				}else{
					if($compile_mode{'bib'}){
						$self->msg(2, 'could not find any bibtex files', 'notice');
						$compile_mode{'latex'} = 1;
					}
				}
			}
			if($compile_mode{'idx'}){
				$self->msg(3, 'run makeindex');
				$self->format_std_out([
					{'type' => 'makeindex', 'cmd' => "makeindex $self->{'tmp_ltx'}",}, 
				]);
				$compile_mode{'latex'} = 1;
			}
			if($compile_mode{'latex'} or 
				$self->changed_orig_files($last_change_time_bak, $last_change_time))
			{
				# if latex file or related files have been changed, then compile w/o using 
				#  bibtex
				# copy orig file to tmp file if not done already
				unless($compile_mode{'bib'}){
					$self->copyfile($self->{'orig_ltx'}, $self->{'tmp_ltx_f'});
				}
				# after bibtex actually pdflatex has to be called twice to avoid citation 
				# warnings. but as the log file is searched for undefined citations, this 
				# second call should be unnecessary.
				$self->msg(3, 'run pdflatex');
				$self->format_std_out([
					{'type' => 'pdflatex', 'cmd' => $complete_latex_command,}, 
				]);
				# && latex -shell-escape -interaction=nonstopmode --halt-on-error 
				# $self->{'orig_ltx'} && dvips $self->{'latexfile'}.dvi 
				# -o $self->{'latexfile'}.ps && ps2pdf $self->{'latexfile'}.ps
			}else{ # else do nothing
				$compiling_counter = 0;
				last if $self->{'no_cont'};
				if($force_error_log){
					my $dummy = [];
					my $extract_errors = $self->extract_usedfiles(
						$self->{'orig_ltx'}, $dummy, 'flsfile');
					$self->parse_tex_log($extract_errors);
				}
				$self->msg(5, 'now sleep 1 and goto loop begin');
				sleep 1;
				next;
			}
			# get filenames of files that are used
			$other_files = [];
			my $extract_errors = $self->extract_usedfiles(
				$self->{'orig_ltx'}, $other_files, 'flsfile');
			$last_change_time_bak = $self->newest_change($other_files);
			%compile_mode = $self->parse_tex_log($extract_errors);
			if(++$compiling_counter > 2 and keys(%compile_mode) > 0){
				$self->msg(0, 'halt loop for there seem to persist errors/warnings.', 
					'notice');
				%compile_mode = ();
			}
			# tmp pdf will be the result and will be copied over target pdf
			if(compare($self->{'tmp_ltx'} . '.pdf', $pdf_file)){
				$self->check_for_pdf_annotations($pdf_file);
				#sleep 2 if $self->{'pdfviewer'} eq 'okular';
				if(defined $self->{'pdfviewer'} 
						and $self->{'pdfviewer'} =~ /^(?:okular|evince)$/){
					sleep 2; # some sleep is necessary, because otherwise copying could be 
					# started before reloading of pdf is finished
				}
				$self->copyfile($self->{'tmp_ltx'} . '.pdf', $pdf_file);
			}
			$self->msg(1, '' . localtime());
		}# end of endless loop
		return 1; # useless, I know
	}

	sub load_latex_editor{
		my $self          = shift;
		my $files         = [grep {m/\.tex\z/} @{$self->{'usedfiles'}}];
		my $latex_editors_string = shift;
		my $latex_editors = [split /\|/, $latex_editors_string];
		if(not defined $latex_editors_string or @$latex_editors==0 or $latex_editors->[0] eq 'none'){
			return undef;
		}
		$self->msg(2, 'search for latex editor');
		my $latex_editor = $self->get_first_found_exe($latex_editors);
		my $pids = $self->get_pids(qr/\Q$latex_editor\E .*\Q$files->[0]\E\b/);
		# load if not loaded already
		if(@$pids==0){
			$self->msg(1, "loading latex editor '$latex_editor'");
			my $latex_editor_cmd = $latex_editor;
			$latex_editor_cmd .= ' -p' if $latex_editor =~ /^g?vim\z/;
			system($latex_editor_cmd . ' ' . (join ' ', @$files) . ' &'); 
		}else{
			$self->msg(1, "latex editor '$latex_editor' loaded already");
		}
		return $latex_editor;
	}

	sub load_pdf_viewer{
		my $self = shift;
		my $pdfviewers = shift;
		my $file = $self->{'latexfile'} . '.pdf';
		if(not defined $pdfviewers or @$pdfviewers == 0 or $pdfviewers->[0] eq 'none'){
			return -1;
		}
		$self->msg(2, 'search for pdf viewer');
		$self->{'pdfviewer'} = $self->get_first_found_exe($pdfviewers);
		return 0 unless defined $self->{'pdfviewer'};
		my $pids = $self->get_pids(qr/\Q$self->{'pdfviewer'}\E .*\Q$file\E\b$/);
		# load if not loaded already
		if(@$pids == 0){
			$self->msg(1, "loading pdf viewer '$self->{'pdfviewer'}'");
			$SIG{'CHLD'} = 'IGNORE'; # avoid creating zombie child
			my $pid = fork();
			defined $pid or die "fork failed; $!\n";
			if($pid == 0){
				$self->msg(1, "file $file does not exist, waiting until it exists.") unless -e $file;
				while(not -e $file){
					sleep 1;
				}
				system("$self->{'pdfviewer'} $file &");
				exit 0;
			}
			return 1;
		}else{
			$self->msg(1, "pdf viewer '$self->{'pdfviewer'}' loaded already");
			return 2;
		}
	}

	sub msg{
		my $self           = shift;
		my $verb_threshold = shift;
		my $msg            = shift;
		my $type           = shift;
		my $caller_inc     = shift // 0;
		return 0 if $self->{'verbosity'} < $verb_threshold;
		$type = (defined $type ? "$type in ": '');
		my $timestamp = POSIX::strftime("%Y-%m-%d %H:%M:%S", gmtime());
		# my ($package, $filename, $line, $subr, $has_args, $wantarray, $evaltext, 
		# $is_require, $hints, $bitmask, $hinthash) = caller(0);
		my @callers = caller(0 + $caller_inc);
		my $line = $callers[2];
		@callers = caller(1 + $caller_inc);
		my $subr = $callers[3] // '[no sub]';
		if($self->{'verbosity'} > 1){
			print "$timestamp $type$subr:$line: ";
		}else{
			print "wolf: ";
		}
		print "$msg\n";
		return 1;
	}

	sub msg_colored{
		my $self           = shift;
		my $verb_threshold = shift;
		my $msg            = shift;
		my $colors         = shift;
		return 0 if $self->{'verbosity'} < $verb_threshold;
		if($self->{'colors'} and defined $colors){
			print colored [$colors], $msg;
		}else{
			print $msg;
		}
		return 1;
	}

	sub newest_change{
		my $self  = shift;
		my $files = shift;
		my $max_date = 0;
		my $newest_file;
		for my $file(@$files){
			next unless -e $file;
			my $mod_ts = (stat $file)[9];
			if($mod_ts > $max_date){
				$max_date = $mod_ts;
				$newest_file = $file;
			}
		}
		if(defined $newest_file){
			$self->msg(3, "newest file: '$newest_file', timestamp = $max_date");
		}
		return $max_date;
	}

	sub ordered_hash_ref{
		my $self = shift;
		tie my %hash, 'Tie::IxHash', @_;
		return \%hash;
	}

	sub parse_tex_log{
		my $self           = shift;
		my $extract_errors = shift;
		my $tmp_bib_log = $self->{'tmp_ltx'} . '.blg'; # used for error parsing
		my $tmp_ltx_log = $self->{'tmp_ltx'} . '.log'; # used for error parsing
		my $log = slurp($tmp_ltx_log);
		my %compile_mode = ();
		# cases, where latex-rerun should help
		if($log =~ /
			LaTeX\sWarning:\s
				Label\(s\)\smay\shave\schanged\.\sRerun\sto\sget\scross-references\sright\.|
			Package\sbiblatex\sWarning:\sPlease\srerun\sLaTeX\.|
			Package\slineno\sWarning:\sLinenumber\sreference\sfailed,\s*\n\s*
			\(lineno\)\s*rerun\sto\sget\sit\sright\.|
			Package\snatbib\sWarning:\sCitation\(s\)\smay\shave\schanged.\s*\n\s*
			\(natbib\)\s*Rerun\sto\sget\scitations\scorrect\.|
			pdfTeX\swarning\s\(dest\):\s # for vim syntax highlighting {
				name\{[^}]+\}\shas\sbeen\sreferenced\sbut\sdoes\snot|
			Package\srerunfilecheck\sWarning:\sFile\s/x
		){
			$self->msg(2, 'found demand on re-compiling');
			$compile_mode{'latex'} = 1;
		}
		# cases, where bibtex should be used (again)
		if($log =~ /(?:LaTeX|Package natbib)\s
			Warning:\sCitation\s.*\son\spage\s\d+\sundefined\son\sinput\sline/x
			# or $log =~ /Package natbib Warning: There were undefined citations/
		){
			$self->msg(2, 'citation undefined, so re-bibtexing');
			$compile_mode{'bib'} = 1;
		}
		# cases, where aux-file should be deleted
		if($log =~ /!\sPackage\sbabel\sError:\sYou\shaven't\sloaded\sthe\slanguage/x){
			$compile_mode{'del_aux'} = 1;
		}
		# use makeindex if necessary
		if($log =~ /Writing\sindex\sfile\s$self->{'tmp_ltx'}\.idx/x){
			$compile_mode{'idx'} = 1;
		}
		# the following major part searches the log for errors, warnings, ...
		# furthermore file-not-found errors are collected
		$self->{'files-not-found'} = [];
		tie my %msgs, 'Tie::IxHash';
		%msgs = (
			'ltx_errs' => {
				'occs'    => $self->ordered_hash_ref(),
				'caption' => 'latex errors',
			},
			'bib_errs' => {
				'occs'    => $self->ordered_hash_ref(),
				'caption' => 'bibtex errors',
			},
			'ltx_warnings' => {
				'occs'    => $self->ordered_hash_ref(),
				'caption' => 'latex warnings',
			},
			'bib_warnings' => {
				'occs'    => $self->ordered_hash_ref(),
				'caption' => 'bibtex warnings',
			},
			'ltx_hyphen' => {
				'occs'    => $self->ordered_hash_ref(),
				'caption' => 'hyphenation problems',
			},
			'ltx_boxes' => {
				'occs'    => $self->ordered_hash_ref(),
				'caption' => 'over-/underfull boxes',
			},
		);
		my $msg;
		if($self->{'verbosity'} >= 1){
			my $biblog = (-e $tmp_bib_log) ? slurp($tmp_bib_log) : undef;
			print "\n";
			$self->msg(0, "summary");
			$self->msg(0, "=======");
			# over-/underfull boxes
			$msg = $msgs{'ltx_boxes'}; #`grep -i -E "full .*box" $tmp_ltx_log`;
			while($log =~ /^(?:Over|Under)full .*box.*(?:\n\[\]\\OT1\/.*)?/mgp){
				++$msg->{'occs'}->{${^MATCH}};
			}
			$self->print_tex_log_messages(
				$msg->{'caption'}, $msg->{'occs'}, $self->{'color-def'}{'notice'});
			# hyphenation problems
			$msg = $msgs{'ltx_hyphen'}; # `grep -iA 2 -E "^\\\\T1/" $tmp_ltx_log`;
			while($log =~ /^(?:\\|\[\]\\O)T1(?:.*+[\n\r]+){2}.*/mgp){
				++$msg->{'occs'}->{${^MATCH}};
			}
			$self->print_tex_log_messages(
				$msg->{'caption'}, $msg->{'occs'}, $self->{'color-def'}{'notice'});
			# bibtex and biber warnings
			$msg = $msgs{'bib_warnings'};
			if(defined $biblog){
				# biber
				while($biblog =~ / WARN - .*/mgp){
					++$msg->{'occs'}->{${^MATCH}};
				}
				# bibtex
				while($biblog =~ /^Warning--.*|I found no \\[a-z]+ command---while .*/mgp){
					++$msg->{'occs'}->{${^MATCH}};
				}
			}
			$self->print_tex_log_messages(
				$msg->{'caption'}, $msg->{'occs'}, $self->{'color-def'}{'warn'});
			# bibtex and biber errors
			$msg = $msgs{'bib_errs'};
			if(defined $biblog){
				while($biblog =~ /^.*\berrors?\b.*(?:\n---.*(?:\n :.*)*)?/mgp){
					next if ${^MATCH} =~ /^\(There was (\d+) error messages?\)/;
					++$msg->{'occs'}->{${^MATCH}};
				}
			}
			$self->print_tex_log_messages(
				$msg->{'caption'}, $msg->{'occs'}, $self->{'color-def'}{'err'});
			# warnings
			$msg = $msgs{'ltx_warnings'}; # `grep -iA 1 warning $tmp_ltx_log`;
			while($log =~ /^
				(?:(?:Class|Package)\s([a-zA-Z0-9_-]+)\s[wW]arning.*(?:\(\1\).*+[\n\r]*)*|
				.*(?i:warning).*+[\n\r]*.*)
			/xmgp){
				my $package = $1;
				next if ${^MATCH} =~ /Package: infwarerr .* Providing info\/warning\/(?:error )?messages? \(HO\)/;
				next if ${^MATCH} =~ /
					^Package:\ssilence\s.*\sfiltering\sof\swarnings\sand\serror\sm|
					\\sl\@(?:BankOf)?Warning|
					LaTeX\sInfo:\sRedefining\s\\GenericWarning
				/x;
				my $w = ${^MATCH};
				$w =~ s/\n\n(?:(?:Class|Package) .*|[\s()]*$)//s;
				# maybe warnings continues on next line(s)
				# space or paranthesis on next line indicate that the warning continues on next line
				if($log =~ /\G(?:\n\x20.+)+/mgcp){ # and $w =~/^Package subfig Warning:/
					$w .= join ' ', split / *\n */, ${^MATCH};
				}elsif(defined $package and $log=~/\G(?:\n\($package\).+)+/mgcp){
					$w .= ${^MATCH};
				}
				# comma and colon indicate that the warning continues on next line
				while($w =~ /[,:]\s*$/){
					$log=~/\G\n.*$/mgp;
					$w .= ${^MATCH};
				}
				# collect unfindable files
				if($w =~ /LaTeX Warning: File `([^']+)' not found/ && 0 == grep {$1 eq $_} @{$self->{'files-not-found'}}){
					push @{$self->{'files-not-found'}}, $1;
				}
				++$msg->{'occs'}->{$w};
			}
			$self->print_tex_log_messages(
				$msg->{'caption'}, $msg->{'occs'}, $self->{'color-def'}{'warn'});
			# errors
			$msg = $msgs{'ltx_errs'}; # `grep -iA 2 -B 1 -E "^!" $tmp_ltx_log`.`grep -iA 1 -B 1 error $tmp_ltx_log`;
			while($log =~ /^(?:
					Package\s([a-zA-Z0-9_-]+)\s[eE]rror.*(?:\(\1\).*+\s*)*| # package errors
					!(?:.*\s+){1,3}l\.\d+(?-s:.*)|              # normal errors indicating a line
					!(?:.*\s+){2}.*|                            # normal errors
					[^:\n]+\.[^:\n]+:[0-9]+:\x20(?:.+\n){1,3}|  # file:line: errors
					.*\berror\b.*+\s*.*                         # other errors
				)/mgxp){
				my $err = ${^MATCH};
				$err =~ s/[\n\r]+$//;
				# check for false positives
				next if $err =~ /Package: infwarerr .* Providing info\/warning\/(?:error )?messages? \(HO\)/;
				next if $err =~ /file:line:error style messages enabled/;
				next if $err =~ /^Package: silence .* filtering of warnings and error m/;
				# collect unfindable files
				if($err =~ /^(.*\sError:\sFile\s`)([^']+)'\snot\sfound\b/s){
					my $fnf_pre = $1;
					my $fnf = $2;
					print "$fnf_pre$fnf\n";
					$fnf =~ s/^(.*)\n/$1 . ' 'x($self->{'max_line_len'}-length($fnf_pre . $1))/egm;
					if(0 == grep {$fnf eq $_} @{$self->{'files-not-found'}}){
						push @{$self->{'files-not-found'}}, $fnf;
					}
				}
				++$msg->{'occs'}->{$err};
				# if bbl-error, then bibtex should be used again
				if($err =~ /\Q$self->{'tmp_ltx'}.bbl/){
					$compile_mode{'bib'} = 1;
				}
			}
			$self->print_tex_log_messages(
				$msg->{'caption'}, $msg->{'occs'}, $self->{'color-def'}{'err'});
			print "\n";
			$self->msg(1, 'summary of summary');
			$self->msg(1, '==================');
			if(@$extract_errors > 0){
				$self->msg(1, '');
				$self->msg(1, 'file reading errors:');
				map {$self->msg(1, " $_")} @$extract_errors;
			}
			for my $m(reverse keys %msgs){
				if(keys(%{$msgs{$m}->{'occs'}}) > 0){
					my $first_occ_message = "first of $msgs{$m}->{'caption'}";
					print "\n";
					$self->msg(1, $first_occ_message);
					$self->msg(1, '=' x length($first_occ_message));
					my $msg = (keys(%{$msgs{$m}->{'occs'}}))[0];
					$msg =~ s/\Q$self->{'tmp_ltx'}/$self->{'latexfile'}/g;
					$self->msg_colored(1, "$msg\n", 
						( substr($m, -4) eq 'errs' ? $self->{'color-def'}{'err'} : 
							substr($m, -8) eq 'warnings' ? $self->{'color-def'}{'warn'} :
							$self->{'color-def'}{'notice'})
					);
					$self->interprate_error($m, $msg);
					print "\n";
				}
			}
			for my $m(reverse values %msgs){
				$self->msg(1, 
					sprintf("% 3d $m->{'caption'} ", scalar(keys %{$m->{'occs'}}))
				);
			}
			print "\n";
		}
		unless($compile_mode{'bib'}){
			if(keys(%{$msgs{'bib_errs'}->{'occs'}}) + 
				keys(%{$msgs{'bib_warnings'}->{'occs'}}) > 0
			){
				$compile_mode{'bib'} = 1;
			}
		}
		return %compile_mode;
	}

	sub print_tex_log_messages{
		my $self   = shift;
		my $type   = shift;
		my $msgs   = shift;
		my $colors = shift;
		if(keys %$msgs > 0){
			print "\n" if $self->{'verbosity'} >= 1;
			$self->msg(1, $type);
			$self->msg(1, '='x(length($type)));
			map {
				my $msg = $_;
				$msg =~ s/\Q$self->{'tmp_ltx'}/$self->{'latexfile'}/g;
				$self->msg_colored(1, $msg . ' ('.$msgs->{$_}."x)\n\n", $colors);
			} keys %$msgs;
		}else{
			#print "\nno $type\n";
		}
	}
}

my $params = syntaxCheck(@ARGV);
my $wolf = Wolf->new({
	'bibtex_params' => {
		'min-crossrefs' => $params->{'min-crossrefs'}
	},
	'colors'          => $params->{'colors'},
	'no_cont'         => $params->{'exit'},
	'format-output'   => $params->{'format-output'},
	'latexfile'       => $params->{'latexfile'},
	'pdflatex-output' => $params->{'pdflatex-output'},
	'pdfviewers'      => [split /\|/, $params->{'pdfviewers'}],
	'verbosity'       => $params->{'verbose'},
});

# check missing files
my $extract_errors = $wolf->extract_usedfiles(undef, undef, 'texfile');
if($params->{'check-missing'} && @$extract_errors > 0 && $params->{'verbose'} > 0){
	my $tex_content = slurp $wolf->{'orig_ltx'};
	unless($tex_content =~ /\\graphicspath/){
		print "\n";
		$wolf->msg(0, 
			'following files could not be found by wolf (but they may be found by pdflatex though):', 
			'warning');
		map {$wolf->msg(0, " $_")} @$extract_errors;
		$wolf->msg(0, "please press <enter> to continue.");
		my $dummy = <STDIN>;
	}
}
# text editor
my $latex_editor = $wolf->load_latex_editor($params->{'editors'});
# start compiling in a loop
$wolf->msg(2, "now running pdflatex in a loop. waiting until file " .
	"'$wolf->{'orig_ltx'}' or included files are changed.");
$wolf->latex_compile();
_clean;
exit ($wolf->{'exit_value'} == 0 ? 0 : 1);

__END__

=head1 NAME

wolf (=work on latex file) provides a simple LaTeX IDE.

=head1 DESCRIPTION

similar to latexmk, this program compiles a latex file to pdf using 'pdflatex' and 
'bibtex' everytime the latex file or bibtex file or included files change.
Additionally this tool opens your favourite latex editor and your favourite 
viewer automatically.
At the end of compiling a summary of all errors and warnings is printed.

=head1 SYNOPSIS

wolf latexfile [options]

  latexfile                latex file to be compiled
      --editor=string      text editor to use (default = choose automatically)
      --min-crossrefs=int  min-crossrefs param for bibtex
      --exit               exit after compilation (default: continue until ctrl-c)
      --no-colors          don't use colors on output
      --no-format-output   don't format output of pdflatex and bibtex
      --pdfviewer=string   pdf viewer to use (default = choose automatically)
      --no-gui             short for --pdfviewer=none --editors=none
      --no-check-missing   don't check for missing files at the begin

  -V, --version            display version and exit.
  -h, --help               display brief help
      --man                display long help (man page)
  -q, --silent             same as --verbose=0
  -v, --verbose            same as --verbose=1 (default)
  -vv,--very-verbose       same as --verbose=2
  -v, --verbose=x          grade of verbosity
                            x=0: no output
                            x=1: default output
                            x=2: much output

=head1 EXAMPLES

  wolf mydoc.tex
    starts gvim (if found), starts kpdf, evince, ocular or acroread (whatever is 
    found first), starts compiling mydoc.tex on every change.

  wolf mydoc
    same as above

=head1 OPTIONS

=over 8

=item B<--no-check-missing>, B<--nocheck-missing>

don't check for missing files at the beginning. this test is not very good, anyway.

=item B<--colors>, B<--no-colors>, B<--nocolors>

wolf is able to use colors for highlighting errors and warnings
default = B<--colors>

=item B<--editor>=I<string>

latex editor that shall be used. default: I<string> = choose automatically from 
one of "gvim|kile|emacs|kate" whatever is found first.

you may choose I<string> as 'emacs' to force trying emacs only or you may choose 
I<string> as 'gvim|emacs' to try gvim at first, and emacs if gvim can't be loaded

if I<string> is 'none', then no editor will be loaded.

=item B<--exit>

by default wolf will run in an endless loop. with setting --exit you can force wolf 
to exit after compilation

=item B<--format-output>, B<--no-format-output>, B<--noformat-output>

wolf is able to re-format the stdout-output of pdflatex and bibtex in a better
readable way. it then tries to indent lines and reformat line-breaks.
default = B<--format-output>

=item B<--no-gui>, B<--nogui>

just a short cut for B<--pdfviewer>=I<none> B<--editor>=I<none>

=item B<--min-crossrefs>=I<int>

bibtex will automatically add a cross-referenced entry to the bibliography if the 
number of references using the cross-reference attribute \crossref is equal to or 
greater than I<int>. if you omit the param, then the default value (normaly 2) 
of bibtex will be used. some bibliography styles need a modification of this param,
e.g. for IEEEtran this should be set to 900, according to 
http://tug.ctan.org/biblio/bibtex/contrib/IEEEtran/IEEEtran_bst_HOWTO.pdf.

wolf tries to detect the bibliography style. if it detects 'IEEEtran', then I<int> 
will be set automatically to 900, unless you did not set it manually.

=item B<--pdflatex-output>, B<--no-pdflatex-output>, B<--nopdflatex-output>

if B<--no-pdflatex-output> is set, pdflatex's output will not be displayed, except 
for summary of errors/warnings

default = B<--pdflatex-output>

=item B<--pdfviewer>=I<string>, B<--pdf-viewer>=I<string>

pdf viewer that shall be used. default: I<string> = choose automatically from one 
of "evince|kpdf|okular|acroread" whatever is found first.

you may choose I<string> as 'okular' to force trying okular only. or you may choose
I<string> as 'kpdf|evince' to try kpdf at first and evince only if kpdf can't be 
loaded.

if I<string> is 'none', then no pdf viewer will be loaded.

=item B<--version>, B<-V>

prints version and exits.

=item B<--help>, B<-h>, B<-?>

prints a brief help message and exits.

=item B<--man>

prints the manual page and exits.

=item B<--verbose>=I<number>, B<-v> I<number>

set grade of verbosity to I<number>. if I<number>==0 then no output
will be given, except hard errors. the higher I<number> is, the more 
output will be printed. default: I<number> = 1.

=item B<--silent, --quiet, -q>

same as B<--verbose=0>.

=item B<--very-verbose, -vv>

same as B<--verbose=3>. you may use B<-vvv> for B<--verbose=4> a.s.o.

=item B<--verbose, -v>

same as B<--verbose=2>.

=back

=head1 LICENCE

Copyright (c) 2017, seth
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

originally written by seth (see https://github.com/wp-seth/wolf)

=cut

